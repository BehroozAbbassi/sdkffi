#include "pch.h"

#include "dtrace.h"
#include "generator/pretty.h"

namespace sdkffi::generator {
namespace dtrace {

std::string
Dtrace::GetHeaderComment()
{
    std::stringstream ss;
    ss << "/*\n\n"
       << " [Script Output]\n\n"
       << " Generated by sdkffi \n"
       << " Output generator module : \n"
       << GetInfo().ToString() << "\n\n"
       << " @BehroozAbbassi\n\n"
       << "*/\n\n";

    return ss.str();
}

bool
Dtrace::Generate(FormatSetting formatSetting)
{
    const auto & dtrace_ret = GetCommands();

    std::ofstream ofs(output_file_name_, std::ios::out);

    //
    // Header file comments
    //
    ofs << GetHeaderComment();

    ofs << "\n\n";
    ofs << "/* -------------------------------- macros -------------------------------- */";
    ofs << "\n\n";

    ofs << "/* dummy names for anonymous struct, enum and unions */\n";

    for (const auto & type : types_.dummy_struct_names)
    {
        ofs << fmt::format("#define {} {}\n", type.name, type.value);
    }
    ofs << "\n";

    for (const auto & type : types_.dummy_union_names)
    {
        ofs << fmt::format("#define {} {}\n", type.name, type.value);
    }
    ofs << "\n";

    for (const auto & type : types_.dummy_enum_names)
    {
        ofs << fmt::format("#define {} {}\n", type.name, type.value);
    }
    ofs << "\n";

    ofs << "\n\n";
    ofs << "/* -------------------------------- typedefs -------------------------------- */";
    ofs << "\n\n";
    // for (const auto & t : types_.Typedefs)
    //{
    //     ofs << fmt::format("typedef {} {};\n", t.type_name, t.alias);
    // }

    std::set<types::Typedef> used_typedefs;
    std::set<types::Struct>  used_structs;

    for (const auto & fn : functions_)
    {
        for (const auto & arg : fn.arguments)
        {
            // auto type_foud = std::find_if(std::begin(types_.Typedefs), std::begin(types_.Typedefs),

            //                              [&arg](const models::type::TypedefDef & type) {
            //                                  if (arg.type == type.type_name || arg.type == type.alias)
            //                                  {
            //                                      return true;
            //                                  }
            //                                  return false;
            //                              });

            for (const auto & type : types_.typedefs)
            {
                if (arg.type == type.type_name || arg.type == type.alias)
                    used_typedefs.insert(type);
            }
        }
    }

    for (const auto & type : types_.typedefs)
    {
        ofs << fmt::format("typedef {} {};\n", type.type_name, type.alias);
    }

    ofs << "\n\n";
    ofs << "/* ------------------------------- structs ------------------------------- */";
    ofs << "\n\n";

    for (const auto & l : types_.structs)
    {
        GetStructDecl(l, ofs);
    }

    ofs << "\n\n";
    ofs << "/* ------------------------------- functions ------------------------------- */";
    ofs << "\n\n";

    for (const auto & l : dtrace_ret)
    {
        ofs << l << "\n";
    }

    ofs.close();

    return true;
}

std::string
Dtrace::GetFormattedFunctionDeclaration(const types::Function & function) const
{
    std::stringstream result;
    const char *      kIndent = "    ";

    pretty::Function fmt_code(function);

    result << function.type << std::endl
           << function.calling_convention << std::endl
           << function.name << "(";

    if (function.arguments.size() > 0)
        result << std::endl;
    else
        result << "VOID";

    const auto max_name_delim_length = fmt_code.GetMaxParameterNameLength();
    const auto max_type_delim_length = fmt_code.GetMaxParameterTypeLength();
    const auto max_sal_delim_length  = fmt_code.GetMaxParameterSalLength();

    for (const auto & param : function.arguments)
    {
        const auto name_delim = pretty::GetWhiteSpaceDelimeter(max_name_delim_length, param.name.length(), 2);
        const auto type_delim = pretty::GetWhiteSpaceDelimeter(max_type_delim_length, param.type.length(), 2);
        const auto sal_delim  = pretty::GetWhiteSpaceDelimeter(max_sal_delim_length, param.annotation.length(), 2);

        result << kIndent << param.annotation << sal_delim << param.type << type_delim << param.name
               << name_delim;

        auto back = function.arguments.back();
        if ((param == back) == false)
            result << ",\n";
    }

    if (function.arguments.size() > 0)
        result << ");\n";
    else
        result << ");\n";

    return result.str();
}
inline std::string
Dtrace::GetParameters(const types::Function & function)
{
    std::string result;

    pretty::Function fmt_code(function);

    const auto max_name_delim_length = fmt_code.GetMaxParameterNameLength();
    const auto max_type_delim_length = fmt_code.GetMaxParameterTypeLength();
    const auto max_sal_delim_length  = fmt_code.GetMaxParameterSalLength();

    uint32_t param_index = 0;
    for (const auto & param : function.arguments)
    {
        // std::stringstream ss;

        const auto name_delim =
            pretty::GetWhiteSpaceDelimeter(max_name_delim_length, param.name.length(), 2);
        const auto type_delim =
            pretty::GetWhiteSpaceDelimeter(max_type_delim_length, param.type.length(), 2);
        const auto sal_delim =
            pretty::GetWhiteSpaceDelimeter(max_sal_delim_length, param.annotation.length(), 2);

        // ss << "#define " << kLocalParameterNamePrefix << param.alias <<
        // name_delim
        //   << "args[" << param_index << "]"
        //   << "  /* " << param.Sal << sal_delim << param.type_kind << type_delim <<
        //   param.alias << name_delim
        //   << " */\n";

        std::string define_arg = fmt::format("#define {0}{1} args[{2}] ", kLocalParameterNamePrefix, param.name + name_delim, param_index);

        std::string comment_arg = fmt::format("/* {0}{1}{2}*/", param.annotation + sal_delim, param.type + type_delim, param.name + name_delim);

        param_index++;
        result.append(define_arg).append(comment_arg).append("\n");
    }

    return result;
}
inline std::string
Dtrace::GenerateLocalParameters(const types::Function & function)
{
    std::string result;

    pretty::Function fmt_code(function);

    const auto max_name_delim_length = fmt_code.GetMaxParameterNameLength();
    const auto max_type_delim_length = fmt_code.GetMaxParameterTypeLength();
    const auto max_sal_delim_length  = fmt_code.GetMaxParameterSalLength();

    //
    // Generate local instance of parameters
    //
    uint32_t param_index = 0;
    for (const auto & param : function.arguments)
    {
        std::stringstream ss;

        const auto name_delim =
            pretty::GetWhiteSpaceDelimeter(max_name_delim_length, param.name.length(), 0);
        const auto type_delim =
            pretty::GetWhiteSpaceDelimeter(max_type_delim_length, param.type.length(), 0);
        const auto sal_delim =
            pretty::GetWhiteSpaceDelimeter(max_sal_delim_length, param.annotation.length(), 0);

        std::string local_var_comment = fmt::format("/* {0} */", param.annotation + sal_delim);

        std::string local_var = fmt::format(
            "{0}this->{1} = ( {2} ) copyin( (uintptr_t) args[{3}], sizeof ( {4} "
            ") ); {5} \n",
            kIndent,
            param.name + name_delim,
            param.type + type_delim,
            param_index,
            param.type + type_delim,
            local_var_comment);

        ss << "    this->" << param.name << name_delim << " = ( " << param.type << type_delim << " ) "
           << "copyin( (uintptr_t) _" << param.name << name_delim << ", sizeof( " << param.type
           << type_delim << " ) );\n";

        result.append(local_var);

        param_index++;
    }

    return result;
}
inline std::string
Dtrace::GenerateLoggerFunction(const types::Function & function)
{
    std::string result;

    std::stringstream ss;
    ss << "    printf(\"["
       << "event"
       << "] " << function.name << "  PID: %05d TID: %05d Time: %x  Process: %-32s\\n\",\n"
       << "           pid,\n"
       << "           tid,\n"
       << "           timestamp,\n"
       << "           execname);\n";

    result = ss.str();

    return result;
}
inline std::string
Dtrace::GenerateActionCode(const types::Function & function)
{
    std::string result;

    const auto & local_parameters_def = GenerateLocalParameters(function);
    const auto & logger_function_def  = GenerateLoggerFunction(function);

    result.append(local_parameters_def).append("\n\n").append(logger_function_def);

    return result;
}
inline Command
Dtrace::GetDtraceCommand(const types::Function & function)
{
    std::string predicate = GetParameters(function);

    //
    // Predicate needs a true expresion to be valid
    //
    predicate.append("\n//\n");
    predicate.append("// Need a valid expression for test\n");
    predicate.append("// You can add your desire conditions here\n");
    predicate.append("//\n");
    predicate.append("\n1==1\n");

    const std::string action = GenerateActionCode(function);

    Command command = {};
    // command.comment = function.DeclarationToString();
    command.comment = GetFormattedFunctionDeclaration(function);

    command.probe.provider = "syscall";
    command.probe.module   = "";
    command.probe.function = function.name;
    command.probe.name     = "return";

    // command.predicate = predicate;
    command.action = action;

    return command;
}
}  // namespace dtrace

}  // namespace sdkffi::generator